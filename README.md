# Сравнительный анализ различных хэш-функций #

## Цель работы ##
 Определить достоинства и недостатки различных хэш функций для хеширования объектов в хэш таблице методом цепочек

## Ход работы ##
 Хеш-таблица - структура для поиска объектов. В таблице, реализованной методом цепочек, поиск по объектам с одинаковым значением хеша осуществляется линейно, поэтому мы заинтересованны в том, чтобы объекты по значениях хеша распределялись равномерно. Вторым важным фактором является скорость вычисления хеша. И оценивать хеш функции мы будем именно по этим двум параметрам 

 Для анализа были взяты 6 хеш-функций. В качестве объектов для анализа были выбраны строки. \
 Ниже указаны описания хеш-функций с их реализация на языке программирования C

 1. Функция возвращает единицу для всех объектов
 ```C
 size_t HashFunction1(const char* object)
 {
    return 1;
 }
 ```
 2. Функция возвращает ASCII-код первого символа входной стоки
 ```C
 size_t HashFunction2(const char* object)
 {
     return object[0];
 }
 ```
 3. Функция возвращает длину входной стоки
 ```C
 size_t HashFunction3(const char* object)
 {
     return strlen(object);
 }
 ```
 4. Вычисление значения 4-ой хеш-функции происходит по алгоритму:\
 В качестве начального значения хеша берётся ASCII-код первого символа входной строки.\
 Чтобы вычислить значение на i-ом шаге, (i-1)-ое значение хеша циклически сдвигается вправо на 1 бит, затем выполняется операция xor с ASCII-кодом i-ого символа входной стоки. Алгоритм останавливается, когда достигается конец входной строки 
 ```C
 size_t HashFunction4(const char* object)
 {
     size_t i    = 0;
     size_t hash = object[i];
     while (object[i] != '\0')
     {
         hash = (((hash & 1) << 63) + (hash >> 1)) ^ object[i];
         i++;
     }
 
     return hash;    
 }
 ```
 5. Вычисление значения 5-ой хеш-функции происходит по следующему алгоритму:\
 Начальное значение хеша - значение ASCII-кода первого символа строки.\
 Чтобы найти значение на i-ом шаге, значение с прошлого шага циклически сдвигается влево на 1 бит, затем осуществляется xor с ASCII-кодом i-го символа входной строки. При достижении конца строки алгоритм завершается 
 ```C
 size_t HashFunction5(const char* object)
 {
     
     size_t i    = 0;
     size_t hash = object[i];
     while (object[i] != '\0')
     {
         hash = (((hash & (1ULL << 63ULL)) >> 63ULL) | (hash << 1ULL)) ^ (size_t)object[i];
         i++;
     }
     
     return hash;
 }
 ```

 6. В качестве 6-ой хеш-функции был выбран crc32
 ```C
 size_t HashFunction6(const Element_t object) 
 {
     unsigned int  result = 0xFFFFFFFF;
     unsigned int  mask   = 0;
     size_t        i      = 0;
 
     while (object[i] != 0)
     {
         result = result ^ (unsigned char)object[i];
 
         for (int j = 7; j >= 0; j--)
         {
             mask   = -(result &  1);
             result =  (result >> 1) ^ (kSrc32HashMask & mask);
         }
         i++;
     }
 
     return ~result;
 }
 ```

 В качестве данных для проверки хеш-функций был взят первый том "Войны и мира". Слова помещались в таблицу, из 997 списков, поэтому значения хеш-функций были взяты по модулю 997. Слова, уже находящиеся в таблице, не добавлялись повторно. Рассмотрим диаграммы, на которых указаны количества слов по значениям хеш-функций

 ### Измерения ###

  | Номер хеш-функции | Среднеквадратичное отклонение |
  |:------------------|:------------------------------|
  | __1__             | __969,9__                     |
  | __2__             | __213,8__                     |
  | __3__             | __319,5__                     |
  | __4__             | __6,6__                       |
  | __5__             | __5,58__                      |
  | __6__             | __5,64__                      |


 ## Анализ ##

 ![](/Data/Hash1.png)

 Очевидно, что __первая__ функция плохо подходит для использования в качестве хеша, так как поиск в хеш-таблице с такой функцией ничем не отличается от линейном поиска в массиве.

 ![](/Data/Hash23.png)

 __Вторая__ и __третья__ хэш функции значительно лучше первой, но они выдают ограниченный диапазон значений.

 Диапазон __второй__ хеш-функция ограничен из-за того, что ASCII-код лежит в пределах от 0 до 255

 Диапазон __третьей__ хеш-функции ограничен, вследствие того, что длина слова ограниченная величина.

 ![](/Data/Hash45.png)
 ![](/Data/Hash56.png)

Четвёртая, пятая и шестая хеш-функции показали лучшие результаты. По среднеквадратичному отклонению можно увидеть, как сильно отличается равномерность распределение первых трёх и последних трёх функций. 

На первой диаграмме видно, что пятая функция выигрывает у четвёртой. Различий у 5-ой и 6-ой функций на диаграмме не видно, но если посмотреть на среднеквадратичное отклонение, можно увидеть, что 5-ая функция распределяет объекты немного равномернее.

## Вывод ##

 Для использования в хеш-таблицах нужна хеш-функция с равномерным распределением значений. Из рассматриваемых функций лучше всего себя показали функции номер 5 и номер 6. Функция 4 также показала неплохие результаты и может быть использована но, возможно, при более длинных строках. Функции 1, 2 и 3 обладают ограниченным диапазоном значений, поэтому применять их для хеширования в хеш-таблицах не стоит

# Ассемблерные оптимизации кода на языке программирования C на примере реализации структуры хэш таблицы методом цепочек #

## Оборудование ##

|                      |  |
-----------------------|-
**Compiler**           | g++ 11.3.0 
**OS**                 | Ubuntu 11.3.0 
**CPU**                | 11th Gen Intel(R) Core(TM) i7-1165G7 @ 2.80GHz

Время измеряется как среднее арифметическое среди 5 измерений

## Начальная версия ##
 |                                                                        |                               |
 |:-----------------------------------------------------------------------|:-----------------------------:|
 |__Флаг сборки:__                                                        |-O1
 |__Время:__                                                              | 6 сек.

 ### Распределение времени работы программы по функциям ###
 ![](/Data/Version0.png)

## Первая оптимизация ##
 
 Больше всего времени программа тратит на сравнение строк. Перепишем функцию strcmp на ассемблере, используя ассемблерную вставку, тем самым избавимся от затрат на вызов.
 
 Было:

 ![](/Data/StrCmp0.png)

 Стало:

 ![](/Data/StrCmp1.png)

 |                                                                        |                               |
 |:-----------------------------------------------------------------------|:-----------------------------:|
 |__Абсолютный коэффициент ускорения:__                                   | 1.11  
 |__Время:__                                                              | 5.42 сек.
 
 ### __Распределение времени работы программы по функциям__ ###
 ![](/Data/Version1.png)

## Вторая оптимизация ##
 Самая времязатратная функция в предыдущей версии - это вычисление 6-ой хеш-функции, то есть crc32. Оптимизируем эту функцию, используя отдельный ассемблерный файл
 
 |                                                                        |                               |
 |:-----------------------------------------------------------------------|:-----------------------------:|
 |__Относительный коэффициент ускорения(относительно предыдущей версии):__| 1.3   
 |__Абсолютный коэффициент ускорения:__                                   | 1.43  
 |__Время:__                                                              | 4.17 сек.

 ### __Распределение времени работы программы по функциям__ ###
 ![](/Data/Version2.png)

## Третья оптимизация ##
 