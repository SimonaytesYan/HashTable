# Сравнительный анализ различных хэш-функций #

## Цель работы ##
 Определить достоинства и недостатки различных хэш функций для хеширования объектов в хэш таблице методом цепочек.

## Ход работы ##
 Хеш-таблица - структура данных для поиска объектов. В таблице, реализованной методом цепочек, поиск по объектам с одинаковым значением хеша осуществляется линейно, поэтому мы заинтересованы в том, чтобы объекты по значениям хеша распределялись равномерно.

 Для анализа были взяты 6 хеш-функций. В качестве объектов для анализа были выбраны строки. \
 Ниже указаны описания хеш-функций с их реализация на языке программирования C.

 1. Функция возвращает единицу для всех объектов:
 ```C
 size_t HashFunction1(const char* object)
 {
    return 1;
 }
 ```
 2. Функция возвращает ASCII-код первого символа входной стоки:
 ```C
 size_t HashFunction2(const char* object)
 {
     return object[0];
 }
 ```
 3. Функция возвращает длину входной стоки:
 ```C
 size_t HashFunction3(const char* object)
 {
     return strlen(object);
 }
 ```
 4. Вычисление значения 4-ой хеш-функции происходит по алгоритму:\
 $ hash[0] = object[0] $\
 $ hash[i] = (hash[i-1] \rightharpoonup 1) \oplus object[i] $

 Где $\rightharpoonup$ - операция циклического битового сдвига вправо на 1 бит, $\oplus$ - побитовый __xor__. Алгоритм останавливается, когда доходит до конца строки
 ```C
 size_t HashFunction4(const char* object)
 {
     size_t i    = 0;
     size_t hash = object[i];
     while (object[i] != '\0')
     {
         hash = (((hash & 1) << 63) + (hash >> 1)) ^ object[i];
         i++;
     }
 
     return hash;    
 }
 ```
 5. Вычисление значения 5-ой хеш-функции происходит по следующему алгоритму:\
 $ hash[0] = object[0] $\
 $ hash[i] = (hash[i-1] \leftharpoonup 1) \oplus object[i] $

 Где $\leftharpoonup$ - операция циклического битового сдвига вправо на 1 бит, $\oplus$ - побитовый __xor__. При достижении конца строки алгоритм завершается
 ```C
 size_t HashFunction5(const char* object)
 {
     
     size_t i    = 0;
     size_t hash = object[i];
     while (object[i] != '\0')
     {
         hash = (((hash & (1ULL << 63ULL)) >> 63ULL) | (hash << 1ULL)) ^ (size_t)object[i];
         i++;
     }
     
     return hash;
 }
 ```

 6. В качестве 6-ой хеш-функции был выбран crc32
 ```C
 size_t HashFunction6(const Element_t object) 
 {
     unsigned int  result = 0xFFFFFFFF;
     unsigned int  mask   = 0;
     size_t        i      = 0;
 
     while (object[i] != 0)
     {
         result = result ^ (unsigned char)object[i];
 
         for (int j = 7; j >= 0; j--)
         {
             mask   = -(result &  1);
             result =  (result >> 1) ^ (kSrc32HashMask & mask);
         }
         i++;
     }
 
     return ~result;
 }
 ```

 В качестве данных для проверки хеш-функций был взят первый том "Войны и мира". Слова помещались в таблицу, из 997 списков, поэтому значения хеш-функций были взяты по модулю 997. Слова, уже находящиеся в таблице, не добавлялись повторно. Рассмотрим диаграммы, на которых указаны количества слов по значениям хеш-функций.

 ## Измерения ##

  | Номер хеш-функции | Среднеквадратичное отклонение |
  |:------------------|:------------------------------|
  | __1__             | __969,9__                     |
  | __2__             | __213,8__                     |
  | __3__             | __319,5__                     |
  | __4__             | __6,6__                       |
  | __5__             | __5,58__                      |
  | __6__             | __5,64__                      |


 ## Анализ ##

 ![](/Data/Hash1.png)

 Очевидно, что __первая__ функция плохо подходит для использования в качестве хеша, так как поиск в хеш-таблице с такой функцией ничем не отличается от линейном поиска в массиве.

 ![](/Data/Hash23.png)

 __Вторая__ и __третья__ хэш функции значительно лучше первой, но они выдают ограниченный диапазон значений.

 Диапазон __второй__ хеш-функция ограничен из-за того, что ASCII-код лежит в пределах от 0 до 255.

 Диапазон __третьей__ хеш-функции ограничен, вследствие того, что длина слова ограниченная величина.

 ![](/Data/Hash45.png)
 ![](/Data/Hash56.png)

__Четвёртая__, __пятая__ и __шестая__ хеш-функции показали лучшие результаты. По среднеквадратичному отклонению можно увидеть, как сильно отличается равномерность распределение первых трёх и последних трёх функций. 

На первой диаграмме видно, что пятая функция выигрывает у четвёртой. Различий у __5-ой__ и __6-ой__ функций на диаграмме не видно, но если посмотреть на среднеквадратичное отклонение, можно увидеть, что __5-ая__ функция распределяет объекты немного равномернее.

## Вывод ##

 Для использования в хеш-таблицах нужна хеш-функция с равномерным распределением значений. Из рассматриваемых функций лучше всего себя показали функции номер 5 и номер 6. Функция 4 также показала неплохие результаты и может быть использована но, возможно, при более длинных строках. Функции 1, 2 и 3 обладают ограниченным диапазоном значений, поэтому применять их для хеширования в хеш-таблицах не стоит.

# Ассемблерные оптимизации кода на языке программирования C на примере оптимизации структуры хэш таблицы методом цепочек #

## Оборудование ##

|                      |  |
-----------------------|-
**Compiler**           | g++ 11.3.0 
**OS**                 | Ubuntu 11.3.0 
**CPU**                | 11th Gen Intel(R) Core(TM) i7-1165G7 @ 2.80GHz

Время измеряется как среднее арифметическое среди 5 измерений.

## Начальная версия ##
 |                                                                        |                               |
 |:-----------------------------------------------------------------------|:-----------------------------:|
 |__Флаг сборки:__                                                        |-O1
 |__Время:__                                                              | 6 ± 0.05 сек.

 ### Распределение времени работы программы по функциям ###
 ![](/Data/Version0.png)

## Первая оптимизация ##
 
 Больше всего времени программа тратит на сравнение строк. Перепишем функцию strcmp на ассемблере, используя ассемблерную вставку, тем самым избавимся от затрат на вызов, а так же используем то, что размер каждой строки фиксирован и равен 64 символа (решение о хранении массивов, а не указателей на строки в хеш-таблице было принято для более оптимального использования кеша). Сделаем сравнение по 8 байт, при этом развернём цикл, чтобы убрать затраты на увеличение счётчика цикла.
 
 Рассмотрим как поменялся ассемблерный код функции

 Было:

 ![](/Data/StrCmp0.png)

 Стало:

 ![](/Data/StrCmp1.png)

 |                                                                        |                               |
 |:-----------------------------------------------------------------------|:-----------------------------:|
 |__Абсолютный коэффициент ускорения:__                                   | 1.11  
 |__Время:__                                                              | 5.39 ± 0.03 сек.
 
 __Замечание:__ если продолжить идею этой оптимизации до сравнения строк, используя AVX512 регистры, то прироста производительности не наблюдается. Наоборот, время работы программы возрастает в таком случае до 30 секунд. Это связано с тем, что единичные инструкции загрузки в AVX регистры, особенно по невыровненному адресу, которые необходимо использовать в этом случае, работают очень долго.

 ### __Распределение времени работы программы по функциям__ ###
 ![](/Data/Version1.png)

## Вторая оптимизация ##
 Самая времязатратная функция в предыдущей версии - это вычисление 6-ой хеш-функции, то есть crc32. Оптимизируем эту функцию, используя отдельный ассемблерный файл. Такое переписывание ускорит программу, так как можно будет использовать ассемблерную инструкцию.

 Было:

  ![](/Data/CRC32_0.png)
 
 Стало:
 ```asm
 hash_crc32:
        mov eax, -1             ; start value
        _loop:
            mov rcx, [rdi]

            test rcx, rcx       ;
            je _ret             ; if (rcx == 0) return rax;

            crc32 rax, rcx

            inc rdi             ; rdi++
            jmp _loop           ; while(al == cl)

        _ret:
        ret
 ```
 Это изменение заменило большое количество ассемблерных инструкций, связанных с вычислением хеша, на одну - crc32. 
 За счёт этого и произошло ускорение.
 
 |                                                                        |                               |
 |:-----------------------------------------------------------------------|:-----------------------------:|
 |__Относительный коэффициент ускорения (относительно предыдущей версии):__| 1.3   
 |__Абсолютный коэффициент ускорения:__                                   | 1.43  
 |__Время:__                                                              | 3.6 ± 0.028 сек.

__Замечание:__ Переписывание хеша с использованием intrinsic функций только ухудшает время работы  

 ### __Распределение времени работы программы по функциям__ ###
 ![](/Data/Version2.png)

## Третья оптимизация ##
 Из-за подключения хеш-функции из файла, компилятор не может заинлайнить её. Напишем реализацию функции в main.cpp файле, используя ассемблерную вставку.

Код функции не поменялся. Она только переместилась из ассемблерного файла в с-шный файл

 |                                                                        |                               |
 |:-----------------------------------------------------------------------|:-----------------------------:|
 |__Относительный коэффициент ускорения (относительно предыдущей версии):__| 1.03   
 |__Абсолютный коэффициент ускорения:__                                   | 1.48  
 |__Время:__                                                              | 3.48 ± 0,017 сек.

 ## Таблица оптимизаций ##

 |__Версия__                                           | __Время__        | ___Относительное ускорение__ | __Абсолютное ускорение__ |
 |:----------------------------------------------------|:-------------:   |:----------------------------:|:------------------------:|
 | Начальная версия                                    | 6 ± 0.05 сек.    | 1                            | 1                        |   
 | Оптимизация strcmp                                  | 5.39 ± 0.03 сек. | 1.11                         | 1.11                     |
 | Вычисление хеша ассемблерной инструкцией            | 3.6 ± 0.028 сек. | 1.5                          | 1.66                     |
 | Вычисление хеша ассемблерной инструкцией + inline   | 3.48 ± 0,017 сек.| 1.03                         | 1.72                     |

 ## Вывод ##
 Ассемблерные оптимизации - это хороший инструмент оптимизации, который позволяет ускорить работы, но к нему стоит прибегать только после того, как все остальные виды оптимизаций были уже использованы.