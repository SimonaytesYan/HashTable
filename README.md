# Сравнительный анализ различных хэш-функций #

## Цель работы ##
 Определить достоинства и недостатки различных хэш функций для хеширования объектов в хэш таблице методом цепочек

## Ход работы ##
 Хеш-таблица - структура для поиска объектов. В таблице, реализованной методом цепочек, поиск по объектам с одинаковым значением хеша осуществляется линейно, поэтому мы заинтересованны в том, чтобы объекты по значениях хеша распределялись равномерно. Вторым важным фактором является скорость вычисления хеша. И оценивать хеш функции мы будем именно по этим двум параметрам 

 Для анализа были взяты 6 хеш-функций. В качестве объектов для анализа были выбраны строки. \
 Ниже указаны описания хеш-функций с их реализация на языке программирования C

 1. Функция возвращает единицу для всех объектов
 ```C
 size_t HashFunction1(const char* object)
 {
    return 1;
 }
 ```
 2. Функция возвращает ASCII-код первого символа входной стоки
 ```C
 size_t HashFunction2(const char* object)
 {
     return object[0];
 }
 ```
 3. Функция возвращает длину входной стоки
 ```C
 size_t HashFunction3(const char* object)
 {
     return strlen(object);
 }
 ```
 4. Вычисление значения 4-ой хеш-функции происходит по алгоритму:\
 В качестве начального значения хеша берётся ASCII-код первого символа входной строки.\
 Чтобы вычислить значение на i-ом шаге, (i-1)-ое значение хеша циклически сдвигается вправо на 1 бит, затем выполняется операция xor с ASCII-кодом i-ого символа входной стоки. Алгоритм останавливается, когда достигается конец входной строки 
 ```C
 size_t HashFunction4(const char* object)
 {
     size_t i    = 0;
     size_t hash = object[i];
     while (object[i] != '\0')
     {
         hash = (((hash & 1) << 63) + (hash >> 1)) ^ object[i];
         i++;
     }
 
     return hash;    
 }
 ```
 5. Вычисление значения 5-ой хеш-функции происходит по следующему алгоритму:\
 Начальное значение хеша - значение ASCII-кода первого символа строки.\
 Чтобы найти значение на i-ом шаге, значение с прошлого шага циклически сдвигается влево на 1 бит, затем осуществляется xor с ASCII-кодом i-го символа входной строки. При достижении конца строки алгоритм завершается 
 ```C
 size_t HashFunction5(const char* object)
 {
     
     size_t i    = 0;
     size_t hash = object[i];
     while (object[i] != '\0')
     {
         hash = (((hash & (1ULL << 63ULL)) >> 63ULL) | (hash << 1ULL)) ^ (size_t)object[i];
         i++;
     }
     
     return hash;
 }
 ```

 6. В качестве 6-ой хеш-функции был выбран GNU-хеш
 ```C
 size_t HashFunction6(const char* object)
 {
     size_t i    = 0;
     size_t hash = 5381;
     while (object[i] != '\0')
     {
         hash = hash * 33 + object[i];
         i++;
     }
 
     return hash;
 }
 ```

 В качестве данных для проверки хеш-функций был взят первый том "Войны и мира". Слова помещались в таблицу, из 997 списков, поэтому значения хеш-функций были взяты по модулю 997. Слова, уже находящиеся в таблице, не добавлялись повторно. Рассмотрим диаграммы, на которых указаны количества слов по значениям хеш-функций

 ### Измерения ###

  | Номер хеш-функции | Среднеквадратичное отклонение | Скорость работы |
  |:------------------|:------------------------------|-----------------|
  | __1__             | __969,9__                     |                 |
  | __2__             | __213,8__                     |                 |
  | __3__             | __319,5__                     |                 |
  | __4__             | __6,6__                       |                 |
  | __5__             | __5,58__                      |                 |
  | __6__             | __5,64__                      |                 |


 ## Анализ ##

 ![](/Data/Hash1.png)

 Очевидно, что __первая__ функция плохо подходит для использования в качестве хеша, так как поиск в хеш-таблице с такой функцией ничем не отличается от линейном поиска в массиве.

 ![](/Data/Hash23.png)

 __Вторая__ и __третья__ хэш функции значительно лучше первой, но они выдают ограниченный диапазон значений.

 Диапазон __второй__ хеш-функция ограничен из-за того, что ASCII-код лежит в пределах от 0 до 255, а учитывая то, что объекты - слова из строчных латинских букв, диапазон сокращается до отрезка от ASCII-кода _'a'_, равного 97 до ASCII-кода _'z'_ равного 122.

 Диапазон __третьей__ хеш-функции ограничен, вследствие того, что длина слова ограниченная величина.

 ![](/Data/Hash45.png)
 ![](/Data/Hash56.png)

Четвёртая, пятая и шестая хеш-функции показали лучшие результаты. По среднеквадратичному отклонению можно увидеть, как сильно отличается равномерность распределение первых трёх и последних трёх функций. 

На первой диаграмме видно, что пятая функция выигрывает у четвёртой. Различий у 5-ой и 6-ой функций на диаграмме не видно, но если посмотреть на среднеквадратичное отклонение, можно увидеть, что 5-ая функция распределяет объекты немного равномернее.

## Вывод ##

 Для использования в хеш-таблицах нужна хеш-функция с равномерным распределением значений. Из рассматриваемых функций лучше всего подходит функция номер 5. Функции 4 и 6 также показали неплохие результаты и могут быть использованы но, возможно, при другом количестве списков в хеш-таблице. Функции 1, 2 и 3 обладают ограниченным диапазоном значений, поэтому применять их для хеширования в хеш-таблицах не стоит

# Ассемблерные оптимизации кода на языке программирования C на примере реализации структуры хэш таблицы методом цепочек #
